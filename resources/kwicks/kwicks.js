// Generated by CoffeeScript 1.6.3
(function() {
  var kwicks;

  kwicks = function(opts) {
    var Kwick, defaults, item, kw_obj, result, setting, _fn, _i, _len, _ref;
    defaults = {
      maxSize: -1,
      minSize: -1,
      spacing: 5,
      duration: 500,
      isVertical: false,
      easing: void 0,
      behavior: null,
      autoResize: true
    };
    setting = {};
    result = {};
    (function() {
      var item, x;
      for (x in defaults) {
        item = defaults[x];
        setting[x] = item;
      }
    })();
    (function() {
      var item, x;
      for (x in opts) {
        item = opts[x];
        setting[x] = item;
      }
    })();
    if (setting.minSize !== -1 && setting.maxSize !== -1) {
      throw new Error("minSize and maxSize 不能同时设置");
    }
    if (setting.behavior && setting.behavior !== 'menu') {
      throw new Error('目前只有menu一种行为');
    }
    _ref = ['minSize', 'maxSize'];
    _fn = function(prop) {
      var val;
      val = setting[prop];
      switch (typeof val) {
        case 'number':
          setting[prop + 'Units'] = 'px';
          break;
        case 'string':
          if (val.slice(-1) === '%') {
            setting[prop + 'Units'] = '%';
            setting[prop] = +val.slice(0, -1);
          } else if (val.slice(-2) === 'px') {
            setting[prop + 'Units'] = 'px';
            setting[prop] = +val.slice(0 - 2);
          } else {
            throw new Error('Invalid value for Kwicks option ' + prop + ': ' + val);
          }
          break;
        default:
          throw new Error('Invalid value for Kwicks option ' + prop + ': ' + val);
      }
    };
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      item = _ref[_i];
      _fn(item);
    }
    Kwick = (function() {
      function Kwick(container, opts) {
        var index, orientation, self, _tempdom;
        this.container = container;
        this.opts = opts;
        self = this;
        orientation = opts.isVertical ? 'vertical' : 'horizontal';
        this.container.className += ' kwicks';
        this.container.className += ' kwicks' + orientation;
        this.panels = this.container.children;
        this.selectedIndex = ((function() {
          var _j, _len1, _ref1, _results;
          _ref1 = self.panels;
          _results = [];
          for (index = _j = 0, _len1 = _ref1.length; _j < _len1; index = ++_j) {
            _tempdom = _ref1[index];
            if (hasClass(_tempdom, 'kwicks-selected')) {
              _results.push(index);
            }
          }
          return _results;
        })())[0];
        this.selectedIndex = this.selectedIndex || -1;
        this.expandedIndex = this.selectedIndex;
        this.primaryDimension = opts.isVertical ? 'height' : 'width';
        this.secondaryDimension = opts.isVertical ? 'width' : 'height';
        this.calculatePanelSizes();
        this.primaryAlignment = opts.isVertical ? 'top' : 'left';
        this.secondaryAlignment = opts.isVertical ? 'bottom' : 'right';
        this.animate = new Animate({
          duration: 500
        });
        this.offsets = this.getOffsetsForExpanded();
        this.initStyles();
        this.initBehavior();
        this.initWindowResizeHandler();
      }

      return Kwick;

    })();
    Kwick.prototype.calculatePanelSizes = function() {
      var containerSize, numPanels, sumPanelSize, sumSpacing;
      opts = this.opts;
      numPanels = this.panels.length;
      containerSize = this.getContainerSize(true);
      sumSpacing = opts.spacing * (numPanels - 1);
      sumPanelSize = containerSize - sumSpacing;
      this.panelSize = sumPanelSize / numPanels;
      if (opts.minSize === -1) {
        if (opts.maxSize === -1) {
          if (numPanels < 5) {
            this.panelMaxSize = containerSize / 3 * 2;
          } else {
            this.panelMaxSize = containerSize / 3;
          }
        } else if (opts.maxSizeUnits === '%') {
          this.panelMaxSize = sumPanelSize * opts.maxSize;
        } else {
          this.panelMaxSize = opts.maxSize;
        }
        this.panelMinSize = (sumPanelSize - this.panelMaxSize) / (numPanels - 1);
      } else if (opts.maxSize === -1) {
        if (opts.minSizeUnits === '%') {
          this.panelMinSize = sumPanelSize * opts.minSize;
          this.panelMinSize = 0;
        } else {
          this.panelMinSize = opts.minSize;
        }
        this.panelMaxSize = sumPanelSize - (this.panelMinSize * (numPanels - 1));
      }
    };
    Kwick.prototype.getOffsetsForExpanded = function() {
      var expandedIndex, i, maxSize, minSize, numPanels, offsets, size, spacing, _j;
      expandedIndex = this.expandedIndex;
      numPanels = this.panels.length;
      spacing = this.opts.spacing;
      size = this.panelSize;
      minSize = this.panelMinSize;
      maxSize = this.panelMaxSize;
      offsets = [0];
      for (i = _j = 1; 1 <= numPanels ? _j < numPanels : _j > numPanels; i = 1 <= numPanels ? ++_j : --_j) {
        if (expandedIndex === -1) {
          offsets[i] = i * (size + spacing);
        } else if (i <= expandedIndex) {
          offsets[i] = i * (minSize + spacing);
        } else {
          offsets[i] = maxSize + (minSize * (i - 1)) + (i * spacing);
        }
      }
      return offsets;
    };
    Kwick.prototype.setStyle = function(el, style) {
      return el.style.cssText = style;
    };
    Kwick.prototype.updatePanelStyles = function() {
      var containerSize, i, j, offset, offsets, pAlign, pDim, panels, prevOffset, sAlign, size, spacing, style, stylePrefix, _j, _ref1;
      offsets = this.offsets;
      panels = this.panels;
      pDim = this.primaryDimension;
      pAlign = this.primaryAlignment;
      sAlign = this.secondaryAlignment;
      spacing = this.opts.spacing;
      containerSize = this.getContainerSize();
      stylePrefix = !!this._stylesInited ? '' : 'position:absolute;';
      for (j = _j = _ref1 = panels.length; _ref1 <= 0 ? _j < 0 : _j > 0; j = _ref1 <= 0 ? ++_j : --_j) {
        i = j - 1;
        prevOffset = offset;
        offset = Math.round(offsets[i]);
        if (i === panels.length - 1) {
          size = containerSize - offset;
          if (size < 0) {
            size = 0;
          }
          style = sAlign + ':0;' + pDim + ':' + size + 'px;';
        } else {
          size = prevOffset - offset - spacing;
          if (size < 0) {
            size = 0;
          }
          style = pAlign + ':' + offset + 'px;' + pDim + ':' + size + 'px;';
        }
        this.setStyle(panels[i], stylePrefix + style);
      }
      if (!this._stylesInited) {
        addClass(this.container, 'kwicks-processed');
        this._stylesInited = true;
      }
    };
    Kwick.prototype.initStyles = function() {
      this.updatePanelStyles();
    };
    Kwick.prototype.initBehavior = function() {
      var c_dom, container, self, _fn1, _j, _len1, _ref1;
      self = this;
      container = this.container;
      appendEvent(container, 'mouseout', function(event) {
        mouseoutEvent(event, container, function() {
          result.expand(container, -1);
        });
      });
      _ref1 = container.children;
      _fn1 = function(_dom) {
        appendEvent(_dom, 'mouseover', function(event) {
          if (!_dom.i_kwicks) {
            if (self.opts.onExpand) {
              self.opts.onExpand(self, _dom);
            }
            result.expand(_dom);
          }
        });
      };
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        c_dom = _ref1[_j];
        _fn1(c_dom);
      }
    };
    Kwick.prototype.initWindowResizeHandler = function() {
      var execScheduled, onResize, prevTime, self;
      if (!this.opts.autoResize) {
        return;
      }
      self = this;
      prevTime = 0;
      execScheduled = false;
      onResize = function(e) {
        var now;
        if (!e) {
          execScheduled = false;
        }
        now = +new Date();
        if (now - prevTime < 20) {
          if (execScheduled) {
            return;
          }
          setTimeout(onResize, 20 - (now - prevTime));
          execScheduled = true;
          return;
        }
        prevTime = now;
        return self.resize();
      };
      appendEvent(window, 'resize', onResize);
    };
    Kwick.prototype.getContainerSize = function(clearCache) {
      var containerSize;
      containerSize = this._containerSize;
      if (clearCache || !containerSize) {
        containerSize = this._containerSize = this.container.scrollWidth;
      }
      return containerSize;
    };
    Kwick.prototype.getExpandedPanel = function() {
      if (this.expandedIndex === -1) {
        return null;
      } else {
        return this.panels[this.expandedIndex];
      }
    };
    Kwick.prototype.getSelectedPanel = function() {
      if (this.selectedIndex === -1) {
        return null;
      } else {
        return this.panels[this.selectedIndex];
      }
    };
    Kwick.prototype.resize = function(index) {
      if (this.getContainerSize() === this.getContainerSize(true)) {
        return;
      }
      this.calculatePanelSizes();
      this.offsets = this.getOffsetsForExpanded();
      if (this.isAnimated) {
        this._dirtyOffsets = true;
      } else {
        this.updatePanelStyles();
      }
    };
    Kwick.prototype.select = function(index) {
      if (index === this.selectedIndex) {
        return this.expand(index);
      }
      removeClass(this.getSelectedPanel(), 'kwicks-selected');
      this.selectedIndex = index;
      addClass(this.getSelectedPanel(), 'kwicks-selected');
      this.expand(index);
    };
    Kwick.prototype.expand = function(index) {
      var animate, numPanels, offsets, self, startOffsets, targetOffsets;
      self = this;
      if (index === -1) {
        index = this.selectedIndex;
      }
      removeClass(this.getExpandedPanel(), 'kwicks-expanded');
      this.expandedIndex = index;
      addClass(this.getExpandedPanel(), 'kwicks-expanded');
      animate = this.animate;
      numPanels = this.panels.length;
      startOffsets = this.offsets.slice();
      offsets = this.offsets;
      targetOffsets = this.getOffsetsForExpanded();
      animate.stop();
      this.isAnimated = true;
      animate.step = function(progress) {
        var i, newOffset, targetOffset, _j;
        if (self._dirtyOffsets) {
          offsets = self.offsets;
          targetOffsets = self.getOffsetsForExpanded();
          self._dirtyOffsets = false;
        }
        offsets.length = 0;
        for (i = _j = 0; 0 <= numPanels ? _j < numPanels : _j > numPanels; i = 0 <= numPanels ? ++_j : --_j) {
          targetOffset = targetOffsets[i];
          newOffset = targetOffset - ((targetOffset - startOffsets[i]) * (1 - progress));
          offsets[i] = newOffset;
        }
        self.updatePanelStyles();
      };
      animate.complete = function() {
        return self.isAnimated = false;
      };
      animate.start();
    };
    kw_obj = new Kwick(setting.container, setting);
    result.expand = function(container, index) {
      var panel;
      if (hasClass(container, 'kwicks-processed')) {
        if (typeof index !== 'number') {
          throw new Error('Kwicks method "expand" requires an index');
        }
        if (index >= 0) {
          panel = container.children[index];
        }
      } else if (hasClass(container.parentNode, 'kwicks-processed')) {
        panel = container;
        index = getDomIndex(panel);
      } else {
        throw new Error('Cannot call "expand" method on a non-Kwicks element');
      }
      kw_obj.expand(index);
    };
    result.expanded = function() {
      return kw_obj.expandedIndex;
    };
    result.select = function(index) {
      var container, panel;
      container = setting.container;
      if (hasClass(container, 'kwicks-processed')) {
        if (typeof index !== 'number') {
          throw new Error('Kwicks method "select" requires an index');
        }
        if (index >= 0) {
          panel = container.children[index];
        }
      } else if (hasClass(container.parentNode, 'kwicks-processed')) {
        panel = container;
        index = getDomIndex(panel);
      } else {
        throw new Error('Cannot call "select" method on a non-Kwicks element');
      }
      kw_obj.select(index);
    };
    result.selected = function() {
      return kw_obj.selectedIndex;
    };
    result.resize = function() {
      return kw_obj.resize();
    };
    return result;
  };

  window.kwicks = kwicks;

}).call(this);
